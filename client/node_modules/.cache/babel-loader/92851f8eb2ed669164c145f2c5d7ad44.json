{"ast":null,"code":"/*\n * Copyright (c) 2022, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15]\n};\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1]\n}; // prettier-ignore\n\nconst ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20]; // prettier-ignore\n\nconst RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\nconst SHIFTS = {\n  p: 0,\n  n: 1,\n  b: 2,\n  r: 3,\n  q: 4,\n  k: 5\n};\nconst BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64\n};\nconst RANK_1 = 7;\nconst RANK_2 = 6;\nconst RANK_3 = 5;\nconst RANK_4 = 4;\nconst RANK_5 = 3;\nconst RANK_6 = 2;\nconst RANK_7 = 1;\nconst RANK_8 = 0; // prettier-ignore\n\nconst SQUARE_MAP = {\n  a8: 0,\n  b8: 1,\n  c8: 2,\n  d8: 3,\n  e8: 4,\n  f8: 5,\n  g8: 6,\n  h8: 7,\n  a7: 16,\n  b7: 17,\n  c7: 18,\n  d7: 19,\n  e7: 20,\n  f7: 21,\n  g7: 22,\n  h7: 23,\n  a6: 32,\n  b6: 33,\n  c6: 34,\n  d6: 35,\n  e6: 36,\n  f6: 37,\n  g6: 38,\n  h6: 39,\n  a5: 48,\n  b5: 49,\n  c5: 50,\n  d5: 51,\n  e5: 52,\n  f5: 53,\n  g5: 54,\n  h5: 55,\n  a4: 64,\n  b4: 65,\n  c4: 66,\n  d4: 67,\n  e4: 68,\n  f4: 69,\n  g4: 70,\n  h4: 71,\n  a3: 80,\n  b3: 81,\n  c3: 82,\n  d3: 83,\n  e3: 84,\n  f3: 85,\n  g3: 86,\n  h3: 87,\n  a2: 96,\n  b2: 97,\n  c2: 98,\n  d2: 99,\n  e2: 100,\n  f2: 101,\n  g2: 102,\n  h2: 103,\n  a1: 112,\n  b1: 113,\n  c1: 114,\n  d1: 115,\n  e1: 116,\n  f1: 117,\n  g1: 118,\n  h1: 119\n};\nconst ROOKS = {\n  w: [{\n    square: SQUARE_MAP.a1,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: SQUARE_MAP.h1,\n    flag: BITS.KSIDE_CASTLE\n  }],\n  b: [{\n    square: SQUARE_MAP.a8,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: SQUARE_MAP.h8,\n    flag: BITS.KSIDE_CASTLE\n  }]\n};\nconst PARSER_STRICT = 0;\nconst PARSER_SLOPPY = 1;\n/* this function is used to uniquely identify ambiguous moves */\n\nfunction get_disambiguator(move, moves) {\n  var from = move.from;\n  var to = move.to;\n  var piece = move.piece;\n  var ambiguities = 0;\n  var same_rank = 0;\n  var same_file = 0;\n\n  for (var i = 0, len = moves.length; i < len; i++) {\n    var ambig_from = moves[i].from;\n    var ambig_to = moves[i].to;\n    var ambig_piece = moves[i].piece;\n    /* if a move of the same piece type ends on the same to square, we'll\n     * need to add a disambiguator to the algebraic notation\n     */\n\n    if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n      ambiguities++;\n\n      if (rank(from) === rank(ambig_from)) {\n        same_rank++;\n      }\n\n      if (file(from) === file(ambig_from)) {\n        same_file++;\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    /* if there exists a similar moving piece on the same rank and file as\n     * the move in question, use the square as the disambiguator\n     */\n    if (same_rank > 0 && same_file > 0) {\n      return algebraic(from);\n    } else if (same_file > 0) {\n      /* if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1);\n    } else {\n      /* else use the file symbol */\n      return algebraic(from).charAt(0);\n    }\n  }\n\n  return '';\n}\n\nfunction infer_piece_type(san) {\n  var piece_type = san.charAt(0);\n\n  if (piece_type >= 'a' && piece_type <= 'h') {\n    var matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n\n    if (matches) {\n      return undefined;\n    }\n\n    return PAWN;\n  }\n\n  piece_type = piece_type.toLowerCase();\n\n  if (piece_type === 'o') {\n    return KING;\n  }\n\n  return piece_type;\n} // parses all of the decorators out of a SAN string\n\n\nfunction stripped_san(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\n/*****************************************************************************\n * UTILITY FUNCTIONS\n ****************************************************************************/\n\n\nfunction rank(i) {\n  return i >> 4;\n}\n\nfunction file(i) {\n  return i & 15;\n}\n\nfunction algebraic(i) {\n  var f = file(i),\n      r = rank(i);\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\n\nfunction swap_color(c) {\n  return c === WHITE ? BLACK : WHITE;\n}\n\nfunction is_digit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n}\n\nfunction clone(obj) {\n  var dupe = obj instanceof Array ? [] : {};\n\n  for (var property in obj) {\n    if (typeof property === 'object') {\n      dupe[property] = clone(obj[property]);\n    } else {\n      dupe[property] = obj[property];\n    }\n  }\n\n  return dupe;\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n/***************************************************************************\n * PUBLIC CONSTANTS\n **************************************************************************/\n\n\nexport const BLACK = 'b';\nexport const WHITE = 'w';\nexport const EMPTY = -1;\nexport const PAWN = 'p';\nexport const KNIGHT = 'n';\nexport const BISHOP = 'b';\nexport const ROOK = 'r';\nexport const QUEEN = 'q';\nexport const KING = 'k';\nexport const SQUARES = function () {\n  /* from the ECMA-262 spec (section 12.6.4):\n   * \"The mechanics of enumerating the properties ... is\n   * implementation dependent\"\n   * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n   * ordered correctly\n   */\n  var keys = [];\n\n  for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n    if (i & 0x88) {\n      i += 7;\n      continue;\n    }\n\n    keys.push(algebraic(i));\n  }\n\n  return keys;\n}();\nexport const FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q'\n};\nexport const Chess = function (fen) {\n  var board = new Array(128);\n  var kings = {\n    w: EMPTY,\n    b: EMPTY\n  };\n  var turn = WHITE;\n  var castling = {\n    w: 0,\n    b: 0\n  };\n  var ep_square = EMPTY;\n  var half_moves = 0;\n  var move_number = 1;\n  var history = [];\n  var header = {};\n  var comments = {};\n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION);\n  } else {\n    load(fen);\n  }\n\n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n\n    board = new Array(128);\n    kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    turn = WHITE;\n    castling = {\n      w: 0,\n      b: 0\n    };\n    ep_square = EMPTY;\n    half_moves = 0;\n    move_number = 1;\n    history = [];\n    if (!keep_headers) header = {};\n    comments = {};\n    update_setup(generate_fen());\n  }\n\n  function prune_comments() {\n    var reversed_history = [];\n    var current_comments = {};\n\n    var copy_comment = function (fen) {\n      if (fen in comments) {\n        current_comments[fen] = comments[fen];\n      }\n    };\n\n    while (history.length > 0) {\n      reversed_history.push(undo_move());\n    }\n\n    copy_comment(generate_fen());\n\n    while (reversed_history.length > 0) {\n      make_move(reversed_history.pop());\n      copy_comment(generate_fen());\n    }\n\n    comments = current_comments;\n  }\n\n  function reset() {\n    load(DEFAULT_POSITION);\n  }\n\n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n\n    var tokens = fen.split(/\\s+/);\n    var position = tokens[0];\n    var square = 0;\n\n    if (!validate_fen(fen).valid) {\n      return false;\n    }\n\n    clear(keep_headers);\n\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i);\n\n      if (piece === '/') {\n        square += 8;\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK;\n        put({\n          type: piece.toLowerCase(),\n          color: color\n        }, algebraic(square));\n        square++;\n      }\n    }\n\n    turn = tokens[1];\n\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE;\n    }\n\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARE_MAP[tokens[3]];\n    half_moves = parseInt(tokens[4], 10);\n    move_number = parseInt(tokens[5], 10);\n    update_setup(generate_fen());\n    return true;\n  }\n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n\n\n  function validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square'\n    };\n    /* 1st criterion: 6 space-seperated fields? */\n\n    var tokens = fen.split(/\\s+/);\n\n    if (tokens.length !== 6) {\n      return {\n        valid: false,\n        error_number: 1,\n        error: errors[1]\n      };\n    }\n    /* 2nd criterion: move number field is a integer value > 0? */\n\n\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return {\n        valid: false,\n        error_number: 2,\n        error: errors[2]\n      };\n    }\n    /* 3rd criterion: half move counter is an integer >= 0? */\n\n\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return {\n        valid: false,\n        error_number: 3,\n        error: errors[3]\n      };\n    }\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n\n\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return {\n        valid: false,\n        error_number: 4,\n        error: errors[4]\n      };\n    }\n    /* 5th criterion: 3th field is a valid castle-string? */\n\n\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return {\n        valid: false,\n        error_number: 5,\n        error: errors[5]\n      };\n    }\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n\n\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return {\n        valid: false,\n        error_number: 6,\n        error: errors[6]\n      };\n    }\n    /* 7th criterion: 1st field contains 8 rows? */\n\n\n    var rows = tokens[0].split('/');\n\n    if (rows.length !== 8) {\n      return {\n        valid: false,\n        error_number: 7,\n        error: errors[7]\n      };\n    }\n    /* 8th criterion: every row is valid? */\n\n\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0;\n      var previous_was_number = false;\n\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return {\n              valid: false,\n              error_number: 8,\n              error: errors[8]\n            };\n          }\n\n          sum_fields += parseInt(rows[i][k], 10);\n          previous_was_number = true;\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return {\n              valid: false,\n              error_number: 9,\n              error: errors[9]\n            };\n          }\n\n          sum_fields += 1;\n          previous_was_number = false;\n        }\n      }\n\n      if (sum_fields !== 8) {\n        return {\n          valid: false,\n          error_number: 10,\n          error: errors[10]\n        };\n      }\n    }\n\n    if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n      return {\n        valid: false,\n        error_number: 11,\n        error: errors[11]\n      };\n    }\n    /* everything's okay! */\n\n\n    return {\n      valid: true,\n      error_number: 0,\n      error: errors[0]\n    };\n  }\n\n  function generate_fen() {\n    var empty = 0;\n    var fen = '';\n\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n      if (board[i] == null) {\n        empty++;\n      } else {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n\n        var color = board[i].color;\n        var piece = board[i].type;\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      }\n\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n\n        if (i !== SQUARE_MAP.h1) {\n          fen += '/';\n        }\n\n        empty = 0;\n        i += 8;\n      }\n    }\n\n    var cflags = '';\n\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K';\n    }\n\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q';\n    }\n\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k';\n    }\n\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q';\n    }\n    /* do we have an empty castling flag? */\n\n\n    cflags = cflags || '-';\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square);\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ');\n  }\n\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1];\n      }\n    }\n\n    return header;\n  }\n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n\n\n  function update_setup(fen) {\n    if (history.length > 0) return;\n\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1';\n      header['FEN'] = fen;\n    } else {\n      delete header['SetUp'];\n      delete header['FEN'];\n    }\n  }\n\n  function get(square) {\n    var piece = board[SQUARE_MAP[square]];\n    return piece ? {\n      type: piece.type,\n      color: piece.color\n    } : null;\n  }\n\n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false;\n    }\n    /* check for piece */\n\n\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false;\n    }\n    /* check for valid square */\n\n\n    if (!(square in SQUARE_MAP)) {\n      return false;\n    }\n\n    var sq = SQUARE_MAP[square];\n    /* don't let the user place more than one king */\n\n    if (piece.type == KING && !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {\n      return false;\n    }\n\n    board[sq] = {\n      type: piece.type,\n      color: piece.color\n    };\n\n    if (piece.type === KING) {\n      kings[piece.color] = sq;\n    }\n\n    update_setup(generate_fen());\n    return true;\n  }\n\n  function remove(square) {\n    var piece = get(square);\n    board[SQUARE_MAP[square]] = null;\n\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY;\n    }\n\n    update_setup(generate_fen());\n    return piece;\n  }\n\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type\n    };\n\n    if (promotion) {\n      move.flags |= BITS.PROMOTION;\n      move.promotion = promotion;\n    }\n\n    if (board[to]) {\n      move.captured = board[to].type;\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN;\n    }\n\n    return move;\n  }\n\n  function generate_moves(options) {\n    function add_move(board, moves, from, to, flags) {\n      /* if pawn promotion */\n      if (board[from].type === PAWN && (rank(to) === RANK_8 || rank(to) === RANK_1)) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];\n\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]));\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags));\n      }\n    }\n\n    var moves = [];\n    var us = turn;\n    var them = swap_color(us);\n    var second_rank = {\n      b: RANK_7,\n      w: RANK_2\n    };\n    var first_sq = SQUARE_MAP.a8;\n    var last_sq = SQUARE_MAP.h1;\n    var single_square = false;\n    /* do we want legal moves? */\n\n    var legal = typeof options !== 'undefined' && 'legal' in options ? options.legal : true;\n    var piece_type = typeof options !== 'undefined' && 'piece' in options && typeof options.piece === 'string' ? options.piece.toLowerCase() : true;\n    /* are we generating moves for a single square? */\n\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARE_MAP) {\n        first_sq = last_sq = SQUARE_MAP[options.square];\n        single_square = true;\n      } else {\n        /* invalid square */\n        return [];\n      }\n    }\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      var piece = board[i];\n\n      if (piece == null || piece.color !== us) {\n        continue;\n      }\n\n      if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0];\n\n        if (board[square] == null) {\n          add_move(board, moves, i, square, BITS.NORMAL);\n          /* double square */\n\n          var square = i + PAWN_OFFSETS[us][1];\n\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN);\n          }\n        }\n        /* pawn captures */\n\n\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j];\n          if (square & 0x88) continue;\n\n          if (board[square] != null && board[square].color === them) {\n            add_move(board, moves, i, square, BITS.CAPTURE);\n          } else if (square === ep_square) {\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);\n          }\n        }\n      } else if (piece_type === true || piece_type === piece.type) {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j];\n          var square = i;\n\n          while (true) {\n            square += offset;\n            if (square & 0x88) break;\n\n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL);\n            } else {\n              if (board[square].color === us) break;\n              add_move(board, moves, i, square, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n\n\n            if (piece.type === 'n' || piece.type === 'k') break;\n          }\n        }\n      }\n    }\n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n\n\n    if (piece_type === true || piece_type === KING) {\n      if (!single_square || last_sq === kings[us]) {\n        /* king-side castling */\n        if (castling[us] & BITS.KSIDE_CASTLE) {\n          var castling_from = kings[us];\n          var castling_to = castling_from + 2;\n\n          if (board[castling_from + 1] == null && board[castling_to] == null && !attacked(them, kings[us]) && !attacked(them, castling_from + 1) && !attacked(them, castling_to)) {\n            add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE);\n          }\n        }\n        /* queen-side castling */\n\n\n        if (castling[us] & BITS.QSIDE_CASTLE) {\n          var castling_from = kings[us];\n          var castling_to = castling_from - 2;\n\n          if (board[castling_from - 1] == null && board[castling_from - 2] == null && board[castling_from - 3] == null && !attacked(them, kings[us]) && !attacked(them, castling_from - 1) && !attacked(them, castling_to)) {\n            add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE);\n          }\n        }\n      }\n    }\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n\n\n    if (!legal) {\n      return moves;\n    }\n    /* filter out illegal moves */\n\n\n    var legal_moves = [];\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i]);\n      }\n\n      undo_move();\n    }\n\n    return legal_moves;\n  }\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n\n  function move_to_san(move, moves) {\n    var output = '';\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      if (move.piece !== PAWN) {\n        var disambiguator = get_disambiguator(move, moves);\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0];\n        }\n\n        output += 'x';\n      }\n\n      output += algebraic(move.to);\n\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n\n    make_move(move);\n\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n\n    undo_move();\n    return output;\n  }\n\n  function attacked(color, square) {\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      /* if empty square or wrong color */\n\n\n      if (board[i] == null || board[i].color !== color) continue;\n      var piece = board[i];\n      var difference = i - square;\n      var index = difference + 119;\n\n      if (ATTACKS[index] & 1 << SHIFTS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true;\n          } else {\n            if (piece.color === BLACK) return true;\n          }\n\n          continue;\n        }\n        /* if the piece is a knight or a king */\n\n\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        var offset = RAYS[index];\n        var j = i + offset;\n        var blocked = false;\n\n        while (j !== square) {\n          if (board[j] != null) {\n            blocked = true;\n            break;\n          }\n\n          j += offset;\n        }\n\n        if (!blocked) return true;\n      }\n    }\n\n    return false;\n  }\n\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color]);\n  }\n\n  function in_check() {\n    return king_attacked(turn);\n  }\n\n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0;\n  }\n\n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0;\n  }\n\n  function insufficient_material() {\n    var pieces = {};\n    var bishops = [];\n    var num_pieces = 0;\n    var sq_color = 0;\n\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n      sq_color = (sq_color + 1) % 2;\n\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      var piece = board[i];\n\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color);\n        }\n\n        num_pieces++;\n      }\n    }\n    /* k vs. k */\n\n\n    if (num_pieces === 2) {\n      return true;\n    } else if (\n    /* k vs. kn .... or .... k vs. kb */\n    num_pieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n      return true;\n    } else if (num_pieces === pieces[BISHOP] + 2) {\n      /* kb vs. kb where any number of bishops are all on the same color */\n      var sum = 0;\n      var len = bishops.length;\n\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = [];\n    var positions = {};\n    var repetition = false;\n\n    while (true) {\n      var move = undo_move();\n      if (!move) break;\n      moves.push(move);\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen().split(' ').slice(0, 4).join(' ');\n      /* has the position occurred three or move times */\n\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n\n      if (!moves.length) {\n        break;\n      }\n\n      make_move(moves.pop());\n    }\n\n    return repetition;\n  }\n\n  function push(move) {\n    history.push({\n      move: move,\n      kings: {\n        b: kings.b,\n        w: kings.w\n      },\n      turn: turn,\n      castling: {\n        b: castling.b,\n        w: castling.w\n      },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number\n    });\n  }\n\n  function make_move(move) {\n    var us = turn;\n    var them = swap_color(us);\n    push(move);\n    board[move.to] = board[move.from];\n    board[move.from] = null;\n    /* if ep capture, remove the captured pawn */\n\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null;\n      } else {\n        board[move.to + 16] = null;\n      }\n    }\n    /* if pawn promotion, replace with new piece */\n\n\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    }\n    /* if we moved the king */\n\n\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to;\n      /* if we castled, move the rook next to the king */\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1;\n        var castling_from = move.to + 1;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1;\n        var castling_from = move.to - 2;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      }\n      /* turn off castling */\n\n\n      castling[us] = '';\n    }\n    /* turn off castling if we move a rook */\n\n\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && castling[us] & ROOKS[us][i].flag) {\n          castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n    /* turn off castling if we capture a rook */\n\n\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && castling[them] & ROOKS[them][i].flag) {\n          castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n    /* if big pawn move, update the en passant square */\n\n\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16;\n      } else {\n        ep_square = move.to + 16;\n      }\n    } else {\n      ep_square = EMPTY;\n    }\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n\n\n    if (move.piece === PAWN) {\n      half_moves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0;\n    } else {\n      half_moves++;\n    }\n\n    if (turn === BLACK) {\n      move_number++;\n    }\n\n    turn = swap_color(turn);\n  }\n\n  function undo_move() {\n    var old = history.pop();\n\n    if (old == null) {\n      return null;\n    }\n\n    var move = old.move;\n    kings = old.kings;\n    turn = old.turn;\n    castling = old.castling;\n    ep_square = old.ep_square;\n    half_moves = old.half_moves;\n    move_number = old.move_number;\n    var us = turn;\n    var them = swap_color(turn);\n    board[move.from] = board[move.to];\n    board[move.from].type = move.piece; // to undo any promotions\n\n    board[move.to] = null;\n\n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = {\n        type: move.captured,\n        color: them\n      };\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index;\n\n      if (us === BLACK) {\n        index = move.to - 16;\n      } else {\n        index = move.to + 16;\n      }\n\n      board[index] = {\n        type: PAWN,\n        color: them\n      };\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from;\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1;\n        castling_from = move.to - 1;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2;\n        castling_from = move.to + 1;\n      }\n\n      board[castling_to] = board[castling_from];\n      board[castling_from] = null;\n    }\n\n    return move;\n  } // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n\n\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    var clean_move = stripped_san(move); // the move parsers is a 2-step state\n\n    for (var parser = 0; parser < 2; parser++) {\n      if (parser == PARSER_SLOPPY) {\n        // only run the sloppy parse if explicitly requested\n        if (!sloppy) {\n          return null;\n        } // The sloppy parser allows the user to parse non-standard chess\n        // notations. This parser is opt-in (by specifying the\n        // '{ sloppy: true }' setting) and is only run after the Standard\n        // Algebraic Notation (SAN) parser has failed.\n        //\n        // When running the sloppy parser, we'll run a regex to grab the piece,\n        // the to/from square, and an optional promotion piece. This regex will\n        // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n        // f7f8q, b1c3\n        // NOTE: Some positions and moves may be ambiguous when using the\n        // sloppy parser. For example, in this position:\n        // 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1, the move b1c3 may be interpreted\n        // as Nc3 or B1c3 (a disambiguated bishop move). In these cases, the\n        // sloppy parser will default to the most most basic interpretation\n        // (which is b1c3 parsing to Nc3).\n        // FIXME: these var's are hoisted into function scope, this will need\n        // to change when switching to const/let\n\n\n        var overly_disambiguated = false;\n        var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n\n        if (matches) {\n          var piece = matches[1];\n          var from = matches[2];\n          var to = matches[3];\n          var promotion = matches[4];\n\n          if (from.length == 1) {\n            overly_disambiguated = true;\n          }\n        } else {\n          // The [a-h]?[1-8]? portion of the regex below handles moves that may\n          // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n          // when there is one legal knight move to e7). In this case, the value\n          // of 'from' variable will be a rank or file, not a square.\n          var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n\n          if (matches) {\n            var piece = matches[1];\n            var from = matches[2];\n            var to = matches[3];\n            var promotion = matches[4];\n\n            if (from.length == 1) {\n              var overly_disambiguated = true;\n            }\n          }\n        }\n      }\n\n      var piece_type = infer_piece_type(clean_move);\n      var moves = generate_moves({\n        legal: true,\n        piece: piece ? piece : piece_type\n      });\n\n      for (var i = 0, len = moves.length; i < len; i++) {\n        switch (parser) {\n          case PARSER_STRICT:\n            {\n              if (clean_move === stripped_san(move_to_san(moves[i], moves))) {\n                return moves[i];\n              }\n\n              break;\n            }\n\n          case PARSER_SLOPPY:\n            {\n              if (matches) {\n                // hand-compare move properties with the results from our sloppy\n                // regex\n                if ((!piece || piece.toLowerCase() == moves[i].piece) && SQUARE_MAP[from] == moves[i].from && SQUARE_MAP[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                  return moves[i];\n                } else if (overly_disambiguated) {\n                  // SPECIAL CASE: we parsed a move string that may have an\n                  // unneeded rank/file disambiguator (e.g. Nge7).  The 'from'\n                  // variable will\n                  var square = algebraic(moves[i].from);\n\n                  if ((!piece || piece.toLowerCase() == moves[i].piece) && SQUARE_MAP[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                  }\n                }\n              }\n            }\n        }\n      }\n    }\n\n    return null;\n  }\n  /* pretty = external move object */\n\n\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move);\n    move.san = move_to_san(move, generate_moves({\n      legal: true\n    }));\n    move.to = algebraic(move.to);\n    move.from = algebraic(move.from);\n    var flags = '';\n\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag];\n      }\n    }\n\n    move.flags = flags;\n    return move;\n  }\n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n\n\n  function perft(depth) {\n    var moves = generate_moves({\n      legal: false\n    });\n    var nodes = 0;\n    var color = turn;\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1);\n          nodes += child_nodes;\n        } else {\n          nodes++;\n        }\n      }\n\n      undo_move();\n    }\n\n    return nodes;\n  }\n\n  return {\n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function (fen) {\n      return load(fen);\n    },\n    reset: function () {\n      return reset();\n    },\n    moves: function (options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n      var ugly_moves = generate_moves(options);\n      var moves = [];\n\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (typeof options !== 'undefined' && 'verbose' in options && options.verbose) {\n          moves.push(make_pretty(ugly_moves[i]));\n        } else {\n          moves.push(move_to_san(ugly_moves[i], generate_moves({\n            legal: true\n          })));\n        }\n      }\n\n      return moves;\n    },\n    in_check: function () {\n      return in_check();\n    },\n    in_checkmate: function () {\n      return in_checkmate();\n    },\n    in_stalemate: function () {\n      return in_stalemate();\n    },\n    in_draw: function () {\n      return half_moves >= 100 || in_stalemate() || insufficient_material() || in_threefold_repetition();\n    },\n    insufficient_material: function () {\n      return insufficient_material();\n    },\n    in_threefold_repetition: function () {\n      return in_threefold_repetition();\n    },\n    game_over: function () {\n      return half_moves >= 100 || in_checkmate() || in_stalemate() || insufficient_material() || in_threefold_repetition();\n    },\n    validate_fen: function (fen) {\n      return validate_fen(fen);\n    },\n    fen: function () {\n      return generate_fen();\n    },\n    board: function () {\n      var output = [],\n          row = [];\n\n      for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n        if (board[i] == null) {\n          row.push(null);\n        } else {\n          row.push({\n            square: algebraic(i),\n            type: board[i].type,\n            color: board[i].color\n          });\n        }\n\n        if (i + 1 & 0x88) {\n          output.push(row);\n          row = [];\n          i += 8;\n        }\n      }\n\n      return output;\n    },\n    pgn: function (options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\n';\n      var max_width = typeof options === 'object' && typeof options.max_width === 'number' ? options.max_width : 0;\n      var result = [];\n      var header_exists = false;\n      /* add the PGN header headerrmation */\n\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline);\n        header_exists = true;\n      }\n\n      if (header_exists && history.length) {\n        result.push(newline);\n      }\n\n      var append_comment = function (move_string) {\n        var comment = comments[generate_fen()];\n\n        if (typeof comment !== 'undefined') {\n          var delimiter = move_string.length > 0 ? ' ' : '';\n          move_string = `${move_string}${delimiter}{${comment}}`;\n        }\n\n        return move_string;\n      };\n      /* pop all of history onto reversed_history */\n\n\n      var reversed_history = [];\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n\n      var moves = [];\n      var move_string = '';\n      /* special case of a commented starting position with no moves */\n\n      if (reversed_history.length === 0) {\n        moves.push(append_comment(''));\n      }\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n\n\n      while (reversed_history.length > 0) {\n        move_string = append_comment(move_string);\n        var move = reversed_history.pop();\n        /* if the position started with black to move, start PGN with 1. ... */\n\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...';\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string);\n          }\n\n          move_string = move_number + '.';\n        }\n\n        move_string = move_string + ' ' + move_to_san(move, generate_moves({\n          legal: true\n        }));\n        make_move(move);\n      }\n      /* are there any other leftover moves? */\n\n\n      if (move_string.length) {\n        moves.push(append_comment(move_string));\n      }\n      /* is there a result? */\n\n\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result);\n      }\n      /* history should be back to what it was before we started generating PGN,\n       * so join together moves\n       */\n\n\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ');\n      }\n\n      var strip = function () {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop();\n          return true;\n        }\n\n        return false;\n      };\n      /* NB: this does not preserve comment whitespace. */\n\n\n      var wrap_comment = function (width, move) {\n        for (var token of move.split(' ')) {\n          if (!token) {\n            continue;\n          }\n\n          if (width + token.length > max_width) {\n            while (strip()) {\n              width--;\n            }\n\n            result.push(newline);\n            width = 0;\n          }\n\n          result.push(token);\n          width += token.length;\n          result.push(' ');\n          width++;\n        }\n\n        if (strip()) {\n          width--;\n        }\n\n        return width;\n      };\n      /* wrap the PGN output at max_width */\n\n\n      var current_width = 0;\n\n      for (var i = 0; i < moves.length; i++) {\n        if (current_width + moves[i].length > max_width) {\n          if (moves[i].includes('{')) {\n            current_width = wrap_comment(current_width, moves[i]);\n            continue;\n          }\n        }\n        /* if the current move will push past max_width */\n\n\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop();\n          }\n\n          result.push(newline);\n          current_width = 0;\n        } else if (i !== 0) {\n          result.push(' ');\n          current_width++;\n        }\n\n        result.push(moves[i]);\n        current_width += moves[i].length;\n      }\n\n      return result.join('');\n    },\n    load_pgn: function (pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\');\n      }\n\n      function has_keys(object) {\n        for (var key in object) {\n          return true;\n        }\n\n        return false;\n      }\n\n      function parse_pgn_header(header, options) {\n        var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n';\n        var header_obj = {};\n        var headers = header.split(new RegExp(mask(newline_char)));\n        var key = '';\n        var value = '';\n\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1');\n\n          if (trim(key).length > 0) {\n            header_obj[key] = value;\n          }\n        }\n\n        return header_obj;\n      }\n\n      var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n'; // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n\n      var header_regex = new RegExp('^(\\\\[((?:' + mask(newline_char) + ')|.)*\\\\])' + '(?:' + mask(newline_char) + '){2}'); // If no header given, begin with moves.\n\n      var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : ''; // Put the board in the starting position\n\n      reset();\n      /* parse PGN header */\n\n      var headers = parse_pgn_header(header_string, options);\n\n      for (var key in headers) {\n        set_header([key, headers[key]]);\n      }\n      /* load the starting position indicated by [Setup '1'] and\n       * [FEN position] */\n\n\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false;\n        }\n      }\n      /* NB: the regexes below that delete move numbers, recursive\n       * annotations, and numeric annotation glyphs may also match\n       * text in comments. To prevent this, we transform comments\n       * by hex-encoding them in place and decoding them again after\n       * the other tokens have been deleted.\n       *\n       * While the spec states that PGN files should be ASCII encoded,\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\n       * as a convenience for modern users */\n\n\n      var to_hex = function (string) {\n        return Array.from(string).map(function (c) {\n          /* encodeURI doesn't transform most ASCII characters,\n           * so we handle these ourselves */\n          return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase();\n        }).join('');\n      };\n\n      var from_hex = function (string) {\n        return string.length == 0 ? '' : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'));\n      };\n\n      var encode_comment = function (string) {\n        string = string.replace(new RegExp(mask(newline_char), 'g'), ' ');\n        return `{${to_hex(string.slice(1, string.length - 1))}}`;\n      };\n\n      var decode_comment = function (string) {\n        if (string.startsWith('{') && string.endsWith('}')) {\n          return from_hex(string.slice(1, string.length - 1));\n        }\n      };\n      /* delete header to get the moves */\n\n\n      var ms = pgn.replace(header_string, '').replace(\n      /* encode comments so they don't get deleted below */\n      new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'), function (match, bracket, semicolon) {\n        return bracket !== undefined ? encode_comment(bracket) : ' ' + encode_comment(`{${semicolon.slice(1)}}`);\n      }).replace(new RegExp(mask(newline_char), 'g'), ' ');\n      /* delete recursive annotation variations */\n\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '');\n      }\n      /* delete move numbers */\n\n\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n      /* delete ... indicating black to move */\n\n      ms = ms.replace(/\\.\\.\\./g, '');\n      /* delete numeric annotation glyphs */\n\n      ms = ms.replace(/\\$\\d+/g, '');\n      /* trim and get array of moves */\n\n      var moves = trim(ms).split(new RegExp(/\\s+/));\n      /* delete empty entries */\n\n      moves = moves.join(',').replace(/,,+/g, ',').split(',');\n      var move = '';\n      var result = '';\n\n      for (var half_move = 0; half_move < moves.length; half_move++) {\n        var comment = decode_comment(moves[half_move]);\n\n        if (comment !== undefined) {\n          comments[generate_fen()] = comment;\n          continue;\n        }\n\n        move = move_from_san(moves[half_move], sloppy);\n        /* invalid move */\n\n        if (move == null) {\n          /* was the move an end of game marker */\n          if (TERMINATION_MARKERS.indexOf(moves[half_move]) > -1) {\n            result = moves[half_move];\n          } else {\n            return false;\n          }\n        } else {\n          /* reset the end of game marker if making a valid move */\n          result = '';\n          make_move(move);\n        }\n      }\n      /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\n       * match the termination marker. Only do this when headers are present,\n       * but the result tag is missing\n       */\n\n\n      if (result && Object.keys(header).length && !header['Result']) {\n        set_header(['Result', result]);\n      }\n\n      return true;\n    },\n    header: function () {\n      return set_header(arguments);\n    },\n    turn: function () {\n      return turn;\n    },\n    move: function (move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n      var move_obj = null;\n\n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy);\n      } else if (typeof move === 'object') {\n        var moves = generate_moves();\n        /* convert the pretty move object to an ugly move object */\n\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n            move_obj = moves[i];\n            break;\n          }\n        }\n      }\n      /* failed to find move */\n\n\n      if (!move_obj) {\n        return null;\n      }\n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n\n\n      var pretty_move = make_pretty(move_obj);\n      make_move(move_obj);\n      return pretty_move;\n    },\n    undo: function () {\n      var move = undo_move();\n      return move ? make_pretty(move) : null;\n    },\n    clear: function () {\n      return clear();\n    },\n    put: function (piece, square) {\n      return put(piece, square);\n    },\n    get: function (square) {\n      return get(square);\n    },\n\n    ascii() {\n      var s = '   +------------------------+\\n';\n\n      for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n        /* display the rank */\n        if (file(i) === 0) {\n          s += ' ' + '87654321'[rank(i)] + ' |';\n        }\n        /* empty piece */\n\n\n        if (board[i] == null) {\n          s += ' . ';\n        } else {\n          var piece = board[i].type;\n          var color = board[i].color;\n          var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n          s += ' ' + symbol + ' ';\n        }\n\n        if (i + 1 & 0x88) {\n          s += '|\\n';\n          i += 8;\n        }\n      }\n\n      s += '   +------------------------+\\n';\n      s += '     a  b  c  d  e  f  g  h';\n      return s;\n    },\n\n    remove: function (square) {\n      return remove(square);\n    },\n    perft: function (depth) {\n      return perft(depth);\n    },\n    square_color: function (square) {\n      if (square in SQUARE_MAP) {\n        var sq_0x88 = SQUARE_MAP[square];\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark';\n      }\n\n      return null;\n    },\n    history: function (options) {\n      var reversed_history = [];\n      var move_history = [];\n      var verbose = typeof options !== 'undefined' && 'verbose' in options && options.verbose;\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop();\n\n        if (verbose) {\n          move_history.push(make_pretty(move));\n        } else {\n          move_history.push(move_to_san(move, generate_moves({\n            legal: true\n          })));\n        }\n\n        make_move(move);\n      }\n\n      return move_history;\n    },\n    get_comment: function () {\n      return comments[generate_fen()];\n    },\n    set_comment: function (comment) {\n      comments[generate_fen()] = comment.replace('{', '[').replace('}', ']');\n    },\n    delete_comment: function () {\n      var comment = comments[generate_fen()];\n      delete comments[generate_fen()];\n      return comment;\n    },\n    get_comments: function () {\n      prune_comments();\n      return Object.keys(comments).map(function (fen) {\n        return {\n          fen: fen,\n          comment: comments[fen]\n        };\n      });\n    },\n    delete_comments: function () {\n      prune_comments();\n      return Object.keys(comments).map(function (fen) {\n        var comment = comments[fen];\n        delete comments[fen];\n        return {\n          fen: fen,\n          comment: comment\n        };\n      });\n    }\n  };\n};","map":{"version":3,"sources":["/Users/m.von-buxhoeveden/Desktop/chess_ai_blue_print/client/node_modules/chess.js/chess.js"],"names":["SYMBOLS","DEFAULT_POSITION","TERMINATION_MARKERS","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","SHIFTS","p","BITS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","RANK_1","RANK_2","RANK_3","RANK_4","RANK_5","RANK_6","RANK_7","RANK_8","SQUARE_MAP","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","ROOKS","square","flag","PARSER_STRICT","PARSER_SLOPPY","get_disambiguator","move","moves","from","to","piece","ambiguities","same_rank","same_file","i","len","length","ambig_from","ambig_to","ambig_piece","rank","file","algebraic","charAt","infer_piece_type","san","piece_type","matches","match","undefined","PAWN","toLowerCase","KING","stripped_san","replace","f","substring","swap_color","c","WHITE","BLACK","is_digit","indexOf","clone","obj","dupe","Array","property","trim","str","EMPTY","KNIGHT","BISHOP","ROOK","QUEEN","SQUARES","keys","push","FLAGS","Chess","fen","board","kings","turn","castling","ep_square","half_moves","move_number","history","header","comments","load","clear","keep_headers","update_setup","generate_fen","prune_comments","reversed_history","current_comments","copy_comment","undo_move","make_move","pop","reset","tokens","split","position","validate_fen","valid","parseInt","color","put","type","errors","error_number","error","isNaN","test","rows","sum_fields","previous_was_number","empty","toUpperCase","cflags","epflags","join","set_header","args","get","sq","remove","build_move","flags","promotion","captured","generate_moves","options","add_move","pieces","us","them","second_rank","first_sq","last_sq","single_square","legal","j","offset","castling_from","castling_to","attacked","legal_moves","king_attacked","move_to_san","output","disambiguator","in_check","in_checkmate","difference","index","blocked","in_stalemate","insufficient_material","bishops","num_pieces","sq_color","sum","in_threefold_repetition","positions","repetition","slice","old","move_from_san","sloppy","clean_move","parser","overly_disambiguated","make_pretty","ugly_move","perft","depth","nodes","child_nodes","ugly_moves","verbose","in_draw","game_over","row","pgn","newline","newline_char","max_width","result","header_exists","append_comment","move_string","comment","delimiter","Result","strip","wrap_comment","width","token","current_width","includes","load_pgn","mask","has_keys","object","key","parse_pgn_header","header_obj","headers","RegExp","value","header_regex","header_string","exec","to_hex","string","map","charCodeAt","toString","encodeURIComponent","from_hex","decodeURIComponent","encode_comment","decode_comment","startsWith","endsWith","ms","bracket","semicolon","rav_regex","half_move","Object","arguments","move_obj","pretty_move","undo","ascii","s","symbol","square_color","sq_0x88","move_history","get_comment","set_comment","delete_comment","get_comments","delete_comments"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2022, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n\nconst SYMBOLS = 'pnbrqkPNBRQK'\n\nconst DEFAULT_POSITION =\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\n\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15],\n}\n\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\n}\n\n// prettier-ignore\nconst ATTACKS = [\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n];\n\n// prettier-ignore\nconst RAYS = [\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n];\n\nconst SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }\n\nconst BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64,\n}\n\nconst RANK_1 = 7\nconst RANK_2 = 6\nconst RANK_3 = 5\nconst RANK_4 = 4\nconst RANK_5 = 3\nconst RANK_6 = 2\nconst RANK_7 = 1\nconst RANK_8 = 0\n\n// prettier-ignore\nconst SQUARE_MAP = {\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\n\nconst ROOKS = {\n  w: [\n    { square: SQUARE_MAP.a1, flag: BITS.QSIDE_CASTLE },\n    { square: SQUARE_MAP.h1, flag: BITS.KSIDE_CASTLE },\n  ],\n  b: [\n    { square: SQUARE_MAP.a8, flag: BITS.QSIDE_CASTLE },\n    { square: SQUARE_MAP.h8, flag: BITS.KSIDE_CASTLE },\n  ],\n}\n\nconst PARSER_STRICT = 0\nconst PARSER_SLOPPY = 1\n\n/* this function is used to uniquely identify ambiguous moves */\nfunction get_disambiguator(move, moves) {\n  var from = move.from\n  var to = move.to\n  var piece = move.piece\n\n  var ambiguities = 0\n  var same_rank = 0\n  var same_file = 0\n\n  for (var i = 0, len = moves.length; i < len; i++) {\n    var ambig_from = moves[i].from\n    var ambig_to = moves[i].to\n    var ambig_piece = moves[i].piece\n\n    /* if a move of the same piece type ends on the same to square, we'll\n     * need to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n      ambiguities++\n\n      if (rank(from) === rank(ambig_from)) {\n        same_rank++\n      }\n\n      if (file(from) === file(ambig_from)) {\n        same_file++\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    /* if there exists a similar moving piece on the same rank and file as\n     * the move in question, use the square as the disambiguator\n     */\n    if (same_rank > 0 && same_file > 0) {\n      return algebraic(from)\n    } else if (same_file > 0) {\n      /* if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1)\n    } else {\n      /* else use the file symbol */\n      return algebraic(from).charAt(0)\n    }\n  }\n\n  return ''\n}\n\nfunction infer_piece_type(san) {\n  var piece_type = san.charAt(0)\n  if (piece_type >= 'a' && piece_type <= 'h') {\n    var matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n    if (matches) {\n      return undefined\n    }\n    return PAWN\n  }\n  piece_type = piece_type.toLowerCase()\n  if (piece_type === 'o') {\n    return KING\n  }\n  return piece_type\n}\n\n// parses all of the decorators out of a SAN string\nfunction stripped_san(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\n/*****************************************************************************\n * UTILITY FUNCTIONS\n ****************************************************************************/\nfunction rank(i) {\n  return i >> 4\n}\n\nfunction file(i) {\n  return i & 15\n}\n\nfunction algebraic(i) {\n  var f = file(i),\n    r = rank(i)\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)\n}\n\nfunction swap_color(c) {\n  return c === WHITE ? BLACK : WHITE\n}\n\nfunction is_digit(c) {\n  return '0123456789'.indexOf(c) !== -1\n}\n\nfunction clone(obj) {\n  var dupe = obj instanceof Array ? [] : {}\n\n  for (var property in obj) {\n    if (typeof property === 'object') {\n      dupe[property] = clone(obj[property])\n    } else {\n      dupe[property] = obj[property]\n    }\n  }\n\n  return dupe\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\n/***************************************************************************\n * PUBLIC CONSTANTS\n **************************************************************************/\n\nexport const BLACK = 'b'\nexport const WHITE = 'w'\n\nexport const EMPTY = -1\n\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\nexport const SQUARES = (function () {\n  /* from the ECMA-262 spec (section 12.6.4):\n   * \"The mechanics of enumerating the properties ... is\n   * implementation dependent\"\n   * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n   * ordered correctly\n   */\n  var keys = []\n  for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n    if (i & 0x88) {\n      i += 7\n      continue\n    }\n    keys.push(algebraic(i))\n  }\n  return keys\n})()\n\nexport const FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q',\n}\n\nexport const Chess = function (fen) {\n  var board = new Array(128)\n  var kings = { w: EMPTY, b: EMPTY }\n  var turn = WHITE\n  var castling = { w: 0, b: 0 }\n  var ep_square = EMPTY\n  var half_moves = 0\n  var move_number = 1\n  var history = []\n  var header = {}\n  var comments = {}\n\n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION)\n  } else {\n    load(fen)\n  }\n\n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    board = new Array(128)\n    kings = { w: EMPTY, b: EMPTY }\n    turn = WHITE\n    castling = { w: 0, b: 0 }\n    ep_square = EMPTY\n    half_moves = 0\n    move_number = 1\n    history = []\n    if (!keep_headers) header = {}\n    comments = {}\n    update_setup(generate_fen())\n  }\n\n  function prune_comments() {\n    var reversed_history = []\n    var current_comments = {}\n    var copy_comment = function (fen) {\n      if (fen in comments) {\n        current_comments[fen] = comments[fen]\n      }\n    }\n    while (history.length > 0) {\n      reversed_history.push(undo_move())\n    }\n    copy_comment(generate_fen())\n    while (reversed_history.length > 0) {\n      make_move(reversed_history.pop())\n      copy_comment(generate_fen())\n    }\n    comments = current_comments\n  }\n\n  function reset() {\n    load(DEFAULT_POSITION)\n  }\n\n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    var tokens = fen.split(/\\s+/)\n    var position = tokens[0]\n    var square = 0\n\n    if (!validate_fen(fen).valid) {\n      return false\n    }\n\n    clear(keep_headers)\n\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK\n        put({ type: piece.toLowerCase(), color: color }, algebraic(square))\n        square++\n      }\n    }\n\n    turn = tokens[1]\n\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARE_MAP[tokens[3]]\n    half_moves = parseInt(tokens[4], 10)\n    move_number = parseInt(tokens[5], 10)\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n  function validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square',\n    }\n\n    /* 1st criterion: 6 space-seperated fields? */\n    var tokens = fen.split(/\\s+/)\n    if (tokens.length !== 6) {\n      return { valid: false, error_number: 1, error: errors[1] }\n    }\n\n    /* 2nd criterion: move number field is a integer value > 0? */\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return { valid: false, error_number: 2, error: errors[2] }\n    }\n\n    /* 3rd criterion: half move counter is an integer >= 0? */\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return { valid: false, error_number: 3, error: errors[3] }\n    }\n\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return { valid: false, error_number: 4, error: errors[4] }\n    }\n\n    /* 5th criterion: 3th field is a valid castle-string? */\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return { valid: false, error_number: 5, error: errors[5] }\n    }\n\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return { valid: false, error_number: 6, error: errors[6] }\n    }\n\n    /* 7th criterion: 1st field contains 8 rows? */\n    var rows = tokens[0].split('/')\n    if (rows.length !== 8) {\n      return { valid: false, error_number: 7, error: errors[7] }\n    }\n\n    /* 8th criterion: every row is valid? */\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0\n      var previous_was_number = false\n\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return { valid: false, error_number: 8, error: errors[8] }\n          }\n          sum_fields += parseInt(rows[i][k], 10)\n          previous_was_number = true\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return { valid: false, error_number: 9, error: errors[9] }\n          }\n          sum_fields += 1\n          previous_was_number = false\n        }\n      }\n      if (sum_fields !== 8) {\n        return { valid: false, error_number: 10, error: errors[10] }\n      }\n    }\n\n    if (\n      (tokens[3][1] == '3' && tokens[1] == 'w') ||\n      (tokens[3][1] == '6' && tokens[1] == 'b')\n    ) {\n      return { valid: false, error_number: 11, error: errors[11] }\n    }\n\n    /* everything's okay! */\n    return { valid: true, error_number: 0, error: errors[0] }\n  }\n\n  function generate_fen() {\n    var empty = 0\n    var fen = ''\n\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n      if (board[i] == null) {\n        empty++\n      } else {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        var color = board[i].color\n        var piece = board[i].type\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== SQUARE_MAP.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    var cflags = ''\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K'\n    }\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q'\n    }\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k'\n    }\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q'\n    }\n\n    /* do we have an empty castling flag? */\n    cflags = cflags || '-'\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square)\n\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ')\n  }\n\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1]\n      }\n    }\n    return header\n  }\n\n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n  function update_setup(fen) {\n    if (history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1'\n      header['FEN'] = fen\n    } else {\n      delete header['SetUp']\n      delete header['FEN']\n    }\n  }\n\n  function get(square) {\n    var piece = board[SQUARE_MAP[square]]\n    return piece ? { type: piece.type, color: piece.color } : null\n  }\n\n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false\n    }\n\n    /* check for piece */\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false\n    }\n\n    /* check for valid square */\n    if (!(square in SQUARE_MAP)) {\n      return false\n    }\n\n    var sq = SQUARE_MAP[square]\n\n    /* don't let the user place more than one king */\n    if (\n      piece.type == KING &&\n      !(kings[piece.color] == EMPTY || kings[piece.color] == sq)\n    ) {\n      return false\n    }\n\n    board[sq] = { type: piece.type, color: piece.color }\n    if (piece.type === KING) {\n      kings[piece.color] = sq\n    }\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  function remove(square) {\n    var piece = get(square)\n    board[SQUARE_MAP[square]] = null\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY\n    }\n\n    update_setup(generate_fen())\n\n    return piece\n  }\n\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type,\n    }\n\n    if (promotion) {\n      move.flags |= BITS.PROMOTION\n      move.promotion = promotion\n    }\n\n    if (board[to]) {\n      move.captured = board[to].type\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN\n    }\n    return move\n  }\n\n  function generate_moves(options) {\n    function add_move(board, moves, from, to, flags) {\n      /* if pawn promotion */\n      if (\n        board[from].type === PAWN &&\n        (rank(to) === RANK_8 || rank(to) === RANK_1)\n      ) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]))\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags))\n      }\n    }\n\n    var moves = []\n    var us = turn\n    var them = swap_color(us)\n    var second_rank = { b: RANK_7, w: RANK_2 }\n\n    var first_sq = SQUARE_MAP.a8\n    var last_sq = SQUARE_MAP.h1\n    var single_square = false\n\n    /* do we want legal moves? */\n    var legal =\n      typeof options !== 'undefined' && 'legal' in options\n        ? options.legal\n        : true\n\n    var piece_type =\n      typeof options !== 'undefined' &&\n      'piece' in options &&\n      typeof options.piece === 'string'\n        ? options.piece.toLowerCase()\n        : true\n\n    /* are we generating moves for a single square? */\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARE_MAP) {\n        first_sq = last_sq = SQUARE_MAP[options.square]\n        single_square = true\n      } else {\n        /* invalid square */\n        return []\n      }\n    }\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece == null || piece.color !== us) {\n        continue\n      }\n\n      if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0]\n        if (board[square] == null) {\n          add_move(board, moves, i, square, BITS.NORMAL)\n\n          /* double square */\n          var square = i + PAWN_OFFSETS[us][1]\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN)\n          }\n        }\n\n        /* pawn captures */\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j]\n          if (square & 0x88) continue\n\n          if (board[square] != null && board[square].color === them) {\n            add_move(board, moves, i, square, BITS.CAPTURE)\n          } else if (square === ep_square) {\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)\n          }\n        }\n      } else if (piece_type === true || piece_type === piece.type) {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j]\n          var square = i\n\n          while (true) {\n            square += offset\n            if (square & 0x88) break\n\n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL)\n            } else {\n              if (board[square].color === us) break\n              add_move(board, moves, i, square, BITS.CAPTURE)\n              break\n            }\n\n            /* break, if knight or king */\n            if (piece.type === 'n' || piece.type === 'k') break\n          }\n        }\n      }\n    }\n\n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n    if (piece_type === true || piece_type === KING) {\n      if (!single_square || last_sq === kings[us]) {\n        /* king-side castling */\n        if (castling[us] & BITS.KSIDE_CASTLE) {\n          var castling_from = kings[us]\n          var castling_to = castling_from + 2\n\n          if (\n            board[castling_from + 1] == null &&\n            board[castling_to] == null &&\n            !attacked(them, kings[us]) &&\n            !attacked(them, castling_from + 1) &&\n            !attacked(them, castling_to)\n          ) {\n            add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)\n          }\n        }\n\n        /* queen-side castling */\n        if (castling[us] & BITS.QSIDE_CASTLE) {\n          var castling_from = kings[us]\n          var castling_to = castling_from - 2\n\n          if (\n            board[castling_from - 1] == null &&\n            board[castling_from - 2] == null &&\n            board[castling_from - 3] == null &&\n            !attacked(them, kings[us]) &&\n            !attacked(them, castling_from - 1) &&\n            !attacked(them, castling_to)\n          ) {\n            add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)\n          }\n        }\n      }\n    }\n\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal) {\n      return moves\n    }\n\n    /* filter out illegal moves */\n    var legal_moves = []\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i])\n      }\n      undo_move()\n    }\n\n    return legal_moves\n  }\n\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  function move_to_san(move, moves) {\n    var output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        var disambiguator = get_disambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    make_move(move)\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    undo_move()\n\n    return output\n  }\n\n  function attacked(color, square) {\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      /* if empty square or wrong color */\n      if (board[i] == null || board[i].color !== color) continue\n\n      var piece = board[i]\n      var difference = i - square\n      var index = difference + 119\n\n      if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true\n          } else {\n            if (piece.color === BLACK) return true\n          }\n          continue\n        }\n\n        /* if the piece is a knight or a king */\n        if (piece.type === 'n' || piece.type === 'k') return true\n\n        var offset = RAYS[index]\n        var j = i + offset\n\n        var blocked = false\n        while (j !== square) {\n          if (board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) return true\n      }\n    }\n\n    return false\n  }\n\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color])\n  }\n\n  function in_check() {\n    return king_attacked(turn)\n  }\n\n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0\n  }\n\n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0\n  }\n\n  function insufficient_material() {\n    var pieces = {}\n    var bishops = []\n    var num_pieces = 0\n    var sq_color = 0\n\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n      sq_color = (sq_color + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color)\n        }\n        num_pieces++\n      }\n    }\n\n    /* k vs. k */\n    if (num_pieces === 2) {\n      return true\n    } else if (\n      /* k vs. kn .... or .... k vs. kb */\n      num_pieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (num_pieces === pieces[BISHOP] + 2) {\n      /* kb vs. kb where any number of bishops are all on the same color */\n      var sum = 0\n      var len = bishops.length\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = []\n    var positions = {}\n    var repetition = false\n\n    while (true) {\n      var move = undo_move()\n      if (!move) break\n      moves.push(move)\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen().split(' ').slice(0, 4).join(' ')\n\n      /* has the position occurred three or move times */\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1\n      if (positions[fen] >= 3) {\n        repetition = true\n      }\n\n      if (!moves.length) {\n        break\n      }\n      make_move(moves.pop())\n    }\n\n    return repetition\n  }\n\n  function push(move) {\n    history.push({\n      move: move,\n      kings: { b: kings.b, w: kings.w },\n      turn: turn,\n      castling: { b: castling.b, w: castling.w },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number,\n    })\n  }\n\n  function make_move(move) {\n    var us = turn\n    var them = swap_color(us)\n    push(move)\n\n    board[move.to] = board[move.from]\n    board[move.from] = null\n\n    /* if ep capture, remove the captured pawn */\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null\n      } else {\n        board[move.to + 16] = null\n      }\n    }\n\n    /* if pawn promotion, replace with new piece */\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = { type: move.promotion, color: us }\n    }\n\n    /* if we moved the king */\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to\n\n      /* if we castled, move the rook next to the king */\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1\n        var castling_from = move.to + 1\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1\n        var castling_from = move.to - 2\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      }\n\n      /* turn off castling */\n      castling[us] = ''\n    }\n\n    /* turn off castling if we move a rook */\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          castling[us] & ROOKS[us][i].flag\n        ) {\n          castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    /* turn off castling if we capture a rook */\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          castling[them] & ROOKS[them][i].flag\n        ) {\n          castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    /* if big pawn move, update the en passant square */\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16\n      } else {\n        ep_square = move.to + 16\n      }\n    } else {\n      ep_square = EMPTY\n    }\n\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n    if (move.piece === PAWN) {\n      half_moves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0\n    } else {\n      half_moves++\n    }\n\n    if (turn === BLACK) {\n      move_number++\n    }\n    turn = swap_color(turn)\n  }\n\n  function undo_move() {\n    var old = history.pop()\n    if (old == null) {\n      return null\n    }\n\n    var move = old.move\n    kings = old.kings\n    turn = old.turn\n    castling = old.castling\n    ep_square = old.ep_square\n    half_moves = old.half_moves\n    move_number = old.move_number\n\n    var us = turn\n    var them = swap_color(turn)\n\n    board[move.from] = board[move.to]\n    board[move.from].type = move.piece // to undo any promotions\n    board[move.to] = null\n\n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = { type: move.captured, color: them }\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index\n      if (us === BLACK) {\n        index = move.to - 16\n      } else {\n        index = move.to + 16\n      }\n      board[index] = { type: PAWN, color: them }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1\n        castling_from = move.to - 1\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2\n        castling_from = move.to + 1\n      }\n\n      board[castling_to] = board[castling_from]\n      board[castling_from] = null\n    }\n\n    return move\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    var clean_move = stripped_san(move)\n\n    // the move parsers is a 2-step state\n    for (var parser = 0; parser < 2; parser++) {\n      if (parser == PARSER_SLOPPY) {\n        // only run the sloppy parse if explicitly requested\n        if (!sloppy) {\n          return null\n        }\n\n        // The sloppy parser allows the user to parse non-standard chess\n        // notations. This parser is opt-in (by specifying the\n        // '{ sloppy: true }' setting) and is only run after the Standard\n        // Algebraic Notation (SAN) parser has failed.\n        //\n        // When running the sloppy parser, we'll run a regex to grab the piece,\n        // the to/from square, and an optional promotion piece. This regex will\n        // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n        // f7f8q, b1c3\n\n        // NOTE: Some positions and moves may be ambiguous when using the\n        // sloppy parser. For example, in this position:\n        // 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1, the move b1c3 may be interpreted\n        // as Nc3 or B1c3 (a disambiguated bishop move). In these cases, the\n        // sloppy parser will default to the most most basic interpretation\n        // (which is b1c3 parsing to Nc3).\n\n        // FIXME: these var's are hoisted into function scope, this will need\n        // to change when switching to const/let\n\n        var overly_disambiguated = false\n\n        var matches = clean_move.match(\n          /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n        )\n        if (matches) {\n          var piece = matches[1]\n          var from = matches[2]\n          var to = matches[3]\n          var promotion = matches[4]\n\n          if (from.length == 1) {\n            overly_disambiguated = true\n          }\n        } else {\n          // The [a-h]?[1-8]? portion of the regex below handles moves that may\n          // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n          // when there is one legal knight move to e7). In this case, the value\n          // of 'from' variable will be a rank or file, not a square.\n          var matches = clean_move.match(\n            /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/\n          )\n\n          if (matches) {\n            var piece = matches[1]\n            var from = matches[2]\n            var to = matches[3]\n            var promotion = matches[4]\n\n            if (from.length == 1) {\n              var overly_disambiguated = true\n            }\n          }\n        }\n      }\n\n      var piece_type = infer_piece_type(clean_move)\n      var moves = generate_moves({\n        legal: true,\n        piece: piece ? piece : piece_type,\n      })\n\n      for (var i = 0, len = moves.length; i < len; i++) {\n        switch (parser) {\n          case PARSER_STRICT: {\n            if (clean_move === stripped_san(move_to_san(moves[i], moves))) {\n              return moves[i]\n            }\n            break\n          }\n          case PARSER_SLOPPY: {\n            if (matches) {\n              // hand-compare move properties with the results from our sloppy\n              // regex\n              if (\n                (!piece || piece.toLowerCase() == moves[i].piece) &&\n                SQUARE_MAP[from] == moves[i].from &&\n                SQUARE_MAP[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)\n              ) {\n                return moves[i]\n              } else if (overly_disambiguated) {\n                // SPECIAL CASE: we parsed a move string that may have an\n                // unneeded rank/file disambiguator (e.g. Nge7).  The 'from'\n                // variable will\n                var square = algebraic(moves[i].from)\n                if (\n                  (!piece || piece.toLowerCase() == moves[i].piece) &&\n                  SQUARE_MAP[to] == moves[i].to &&\n                  (from == square[0] || from == square[1]) &&\n                  (!promotion || promotion.toLowerCase() == moves[i].promotion)\n                ) {\n                  return moves[i]\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return null\n  }\n\n  /* pretty = external move object */\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move)\n    move.san = move_to_san(move, generate_moves({ legal: true }))\n    move.to = algebraic(move.to)\n    move.from = algebraic(move.from)\n\n    var flags = ''\n\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag]\n      }\n    }\n    move.flags = flags\n\n    return move\n  }\n\n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n  function perft(depth) {\n    var moves = generate_moves({ legal: false })\n    var nodes = 0\n    var color = turn\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1)\n          nodes += child_nodes\n        } else {\n          nodes++\n        }\n      }\n      undo_move()\n    }\n\n    return nodes\n  }\n\n  return {\n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function (fen) {\n      return load(fen)\n    },\n\n    reset: function () {\n      return reset()\n    },\n\n    moves: function (options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n\n      var ugly_moves = generate_moves(options)\n      var moves = []\n\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (\n          typeof options !== 'undefined' &&\n          'verbose' in options &&\n          options.verbose\n        ) {\n          moves.push(make_pretty(ugly_moves[i]))\n        } else {\n          moves.push(\n            move_to_san(ugly_moves[i], generate_moves({ legal: true }))\n          )\n        }\n      }\n\n      return moves\n    },\n\n    in_check: function () {\n      return in_check()\n    },\n\n    in_checkmate: function () {\n      return in_checkmate()\n    },\n\n    in_stalemate: function () {\n      return in_stalemate()\n    },\n\n    in_draw: function () {\n      return (\n        half_moves >= 100 ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    insufficient_material: function () {\n      return insufficient_material()\n    },\n\n    in_threefold_repetition: function () {\n      return in_threefold_repetition()\n    },\n\n    game_over: function () {\n      return (\n        half_moves >= 100 ||\n        in_checkmate() ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    validate_fen: function (fen) {\n      return validate_fen(fen)\n    },\n\n    fen: function () {\n      return generate_fen()\n    },\n\n    board: function () {\n      var output = [],\n        row = []\n\n      for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n        if (board[i] == null) {\n          row.push(null)\n        } else {\n          row.push({\n            square: algebraic(i),\n            type: board[i].type,\n            color: board[i].color,\n          })\n        }\n        if ((i + 1) & 0x88) {\n          output.push(row)\n          row = []\n          i += 8\n        }\n      }\n\n      return output\n    },\n\n    pgn: function (options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\n'\n      var max_width =\n        typeof options === 'object' && typeof options.max_width === 'number'\n          ? options.max_width\n          : 0\n      var result = []\n      var header_exists = false\n\n      /* add the PGN header headerrmation */\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline)\n        header_exists = true\n      }\n\n      if (header_exists && history.length) {\n        result.push(newline)\n      }\n\n      var append_comment = function (move_string) {\n        var comment = comments[generate_fen()]\n        if (typeof comment !== 'undefined') {\n          var delimiter = move_string.length > 0 ? ' ' : ''\n          move_string = `${move_string}${delimiter}{${comment}}`\n        }\n        return move_string\n      }\n\n      /* pop all of history onto reversed_history */\n      var reversed_history = []\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      var moves = []\n      var move_string = ''\n\n      /* special case of a commented starting position with no moves */\n      if (reversed_history.length === 0) {\n        moves.push(append_comment(''))\n      }\n\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n      while (reversed_history.length > 0) {\n        move_string = append_comment(move_string)\n        var move = reversed_history.pop()\n\n        /* if the position started with black to move, start PGN with 1. ... */\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...'\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string)\n          }\n          move_string = move_number + '.'\n        }\n\n        move_string =\n          move_string + ' ' + move_to_san(move, generate_moves({ legal: true }))\n        make_move(move)\n      }\n\n      /* are there any other leftover moves? */\n      if (move_string.length) {\n        moves.push(append_comment(move_string))\n      }\n\n      /* is there a result? */\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result)\n      }\n\n      /* history should be back to what it was before we started generating PGN,\n       * so join together moves\n       */\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ')\n      }\n\n      var strip = function () {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop()\n          return true\n        }\n        return false\n      }\n\n      /* NB: this does not preserve comment whitespace. */\n      var wrap_comment = function (width, move) {\n        for (var token of move.split(' ')) {\n          if (!token) {\n            continue\n          }\n          if (width + token.length > max_width) {\n            while (strip()) {\n              width--\n            }\n            result.push(newline)\n            width = 0\n          }\n          result.push(token)\n          width += token.length\n          result.push(' ')\n          width++\n        }\n        if (strip()) {\n          width--\n        }\n        return width\n      }\n\n      /* wrap the PGN output at max_width */\n      var current_width = 0\n      for (var i = 0; i < moves.length; i++) {\n        if (current_width + moves[i].length > max_width) {\n          if (moves[i].includes('{')) {\n            current_width = wrap_comment(current_width, moves[i])\n            continue\n          }\n        }\n        /* if the current move will push past max_width */\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop()\n          }\n\n          result.push(newline)\n          current_width = 0\n        } else if (i !== 0) {\n          result.push(' ')\n          current_width++\n        }\n        result.push(moves[i])\n        current_width += moves[i].length\n      }\n\n      return result.join('')\n    },\n\n    load_pgn: function (pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\')\n      }\n\n      function has_keys(object) {\n        for (var key in object) {\n          return true\n        }\n        return false\n      }\n\n      function parse_pgn_header(header, options) {\n        var newline_char =\n          typeof options === 'object' &&\n          typeof options.newline_char === 'string'\n            ? options.newline_char\n            : '\\r?\\n'\n        var header_obj = {}\n        var headers = header.split(new RegExp(mask(newline_char)))\n        var key = ''\n        var value = ''\n\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1')\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1')\n          if (trim(key).length > 0) {\n            header_obj[key] = value\n          }\n        }\n\n        return header_obj\n      }\n\n      var newline_char =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\r?\\n'\n\n      // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n      var header_regex = new RegExp(\n        '^(\\\\[((?:' +\n          mask(newline_char) +\n          ')|.)*\\\\])' +\n          '(?:' +\n          mask(newline_char) +\n          '){2}'\n      )\n\n      // If no header given, begin with moves.\n      var header_string = header_regex.test(pgn)\n        ? header_regex.exec(pgn)[1]\n        : ''\n\n      // Put the board in the starting position\n      reset()\n\n      /* parse PGN header */\n      var headers = parse_pgn_header(header_string, options)\n      for (var key in headers) {\n        set_header([key, headers[key]])\n      }\n\n      /* load the starting position indicated by [Setup '1'] and\n       * [FEN position] */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false\n        }\n      }\n\n      /* NB: the regexes below that delete move numbers, recursive\n       * annotations, and numeric annotation glyphs may also match\n       * text in comments. To prevent this, we transform comments\n       * by hex-encoding them in place and decoding them again after\n       * the other tokens have been deleted.\n       *\n       * While the spec states that PGN files should be ASCII encoded,\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\n       * as a convenience for modern users */\n\n      var to_hex = function (string) {\n        return Array.from(string)\n          .map(function (c) {\n            /* encodeURI doesn't transform most ASCII characters,\n             * so we handle these ourselves */\n            return c.charCodeAt(0) < 128\n              ? c.charCodeAt(0).toString(16)\n              : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase()\n          })\n          .join('')\n      }\n\n      var from_hex = function (string) {\n        return string.length == 0\n          ? ''\n          : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'))\n      }\n\n      var encode_comment = function (string) {\n        string = string.replace(new RegExp(mask(newline_char), 'g'), ' ')\n        return `{${to_hex(string.slice(1, string.length - 1))}}`\n      }\n\n      var decode_comment = function (string) {\n        if (string.startsWith('{') && string.endsWith('}')) {\n          return from_hex(string.slice(1, string.length - 1))\n        }\n      }\n\n      /* delete header to get the moves */\n      var ms = pgn\n        .replace(header_string, '')\n        .replace(\n          /* encode comments so they don't get deleted below */\n          new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'),\n          function (match, bracket, semicolon) {\n            return bracket !== undefined\n              ? encode_comment(bracket)\n              : ' ' + encode_comment(`{${semicolon.slice(1)}}`)\n          }\n        )\n        .replace(new RegExp(mask(newline_char), 'g'), ' ')\n\n      /* delete recursive annotation variations */\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '')\n      }\n\n      /* delete move numbers */\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n      /* delete ... indicating black to move */\n      ms = ms.replace(/\\.\\.\\./g, '')\n\n      /* delete numeric annotation glyphs */\n      ms = ms.replace(/\\$\\d+/g, '')\n\n      /* trim and get array of moves */\n      var moves = trim(ms).split(new RegExp(/\\s+/))\n\n      /* delete empty entries */\n      moves = moves.join(',').replace(/,,+/g, ',').split(',')\n      var move = ''\n\n      var result = ''\n\n      for (var half_move = 0; half_move < moves.length; half_move++) {\n        var comment = decode_comment(moves[half_move])\n        if (comment !== undefined) {\n          comments[generate_fen()] = comment\n          continue\n        }\n\n        move = move_from_san(moves[half_move], sloppy)\n\n        /* invalid move */\n        if (move == null) {\n          /* was the move an end of game marker */\n          if (TERMINATION_MARKERS.indexOf(moves[half_move]) > -1) {\n            result = moves[half_move]\n          } else {\n            return false\n          }\n        } else {\n          /* reset the end of game marker if making a valid move */\n          result = ''\n          make_move(move)\n        }\n      }\n\n      /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\n       * match the termination marker. Only do this when headers are present,\n       * but the result tag is missing\n       */\n      if (result && Object.keys(header).length && !header['Result']) {\n        set_header(['Result', result])\n      }\n\n      return true\n    },\n\n    header: function () {\n      return set_header(arguments)\n    },\n\n    turn: function () {\n      return turn\n    },\n\n    move: function (move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      var move_obj = null\n\n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy)\n      } else if (typeof move === 'object') {\n        var moves = generate_moves()\n\n        /* convert the pretty move object to an ugly move object */\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (\n            move.from === algebraic(moves[i].from) &&\n            move.to === algebraic(moves[i].to) &&\n            (!('promotion' in moves[i]) ||\n              move.promotion === moves[i].promotion)\n          ) {\n            move_obj = moves[i]\n            break\n          }\n        }\n      }\n\n      /* failed to find move */\n      if (!move_obj) {\n        return null\n      }\n\n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n      var pretty_move = make_pretty(move_obj)\n\n      make_move(move_obj)\n\n      return pretty_move\n    },\n\n    undo: function () {\n      var move = undo_move()\n      return move ? make_pretty(move) : null\n    },\n\n    clear: function () {\n      return clear()\n    },\n\n    put: function (piece, square) {\n      return put(piece, square)\n    },\n\n    get: function (square) {\n      return get(square)\n    },\n\n    ascii() {\n      var s = '   +------------------------+\\n'\n      for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n        /* display the rank */\n        if (file(i) === 0) {\n          s += ' ' + '87654321'[rank(i)] + ' |'\n        }\n\n        /* empty piece */\n        if (board[i] == null) {\n          s += ' . '\n        } else {\n          var piece = board[i].type\n          var color = board[i].color\n          var symbol =\n            color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n          s += ' ' + symbol + ' '\n        }\n\n        if ((i + 1) & 0x88) {\n          s += '|\\n'\n          i += 8\n        }\n      }\n      s += '   +------------------------+\\n'\n      s += '     a  b  c  d  e  f  g  h'\n\n      return s\n    },\n\n    remove: function (square) {\n      return remove(square)\n    },\n\n    perft: function (depth) {\n      return perft(depth)\n    },\n\n    square_color: function (square) {\n      if (square in SQUARE_MAP) {\n        var sq_0x88 = SQUARE_MAP[square]\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'\n      }\n\n      return null\n    },\n\n    history: function (options) {\n      var reversed_history = []\n      var move_history = []\n      var verbose =\n        typeof options !== 'undefined' &&\n        'verbose' in options &&\n        options.verbose\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop()\n        if (verbose) {\n          move_history.push(make_pretty(move))\n        } else {\n          move_history.push(move_to_san(move, generate_moves({ legal: true })))\n        }\n        make_move(move)\n      }\n\n      return move_history\n    },\n\n    get_comment: function () {\n      return comments[generate_fen()]\n    },\n\n    set_comment: function (comment) {\n      comments[generate_fen()] = comment.replace('{', '[').replace('}', ']')\n    },\n\n    delete_comment: function () {\n      var comment = comments[generate_fen()]\n      delete comments[generate_fen()]\n      return comment\n    },\n\n    get_comments: function () {\n      prune_comments()\n      return Object.keys(comments).map(function (fen) {\n        return { fen: fen, comment: comments[fen] }\n      })\n    },\n\n    delete_comments: function () {\n      prune_comments()\n      return Object.keys(comments).map(function (fen) {\n        var comment = comments[fen]\n        delete comments[fen]\n        return { fen: fen, comment: comment }\n      })\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"module"}